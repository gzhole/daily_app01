const epssService = require('./epss-service-simple');
const { scanForVulnerabilities } = require('./security-utils');

class VulnerabilityManager {
  constructor() {
    this.vulnerabilityCache = new Map();
    this.cacheTtl = 24 * 60 * 60 * 1000; // 24 hours
  }

  /**
   * Scans code for vulnerabilities and enhances them with EPSS scores
   * @param {string} code - The source code to analyze
   * @param {string} [language='javascript'] - The programming language of the code
   * @param {Function} callback - Callback function (err, results)
   */
  scanCodeWithEPSS(code, language = 'javascript', callback) {
    // First, scan for vulnerabilities using the existing scanner
    const scanResults = scanForVulnerabilities(code, language);
    
    if (!scanResults.hasVulnerabilities) {
      return callback(null, scanResults);
    }

    // Extract unique CVE IDs from vulnerability descriptions
    const cveIds = this.extractCVEIds(scanResults.vulnerabilities);
    
    if (cveIds.length === 0) {
      return callback(null, scanResults);
    }

    // Get EPSS scores for all CVEs
    epssService.getBatchEpsScores(cveIds, (err, epssScores) => {
      if (err) {
        console.warn('Failed to fetch EPSS scores:', err);
        return callback(null, scanResults);
      }

      // Enhance vulnerabilities with EPSS data
      const enhancedVulnerabilities = scanResults.vulnerabilities.map(vuln => {
        const cveId = this.extractCVEId(vuln.description);
        if (cveId && epssScores[cveId]) {
          return {
            ...vuln,
            epssScore: parseFloat(epssScores[cveId].epss),
            epssPercentile: parseFloat(epssScores[cveId].percentile),
            epssDate: epssScores[cveId].date
          };
        }
        return vuln;
      });

      // Sort by EPSS score (highest first) and then by severity
      enhancedVulnerabilities.sort((a, b) => {
        const scoreA = a.epssScore || 0;
        const scoreB = b.epssScore || 0;
        if (scoreA !== scoreB) return scoreB - scoreA;
        return b.severity - a.severity;
      });

      callback(null, {
        ...scanResults,
        vulnerabilities: enhancedVulnerabilities,
        enhancedWithEPSS: true
      });
    });
  }

  /**
   * Extracts CVE IDs from vulnerability descriptions
   * @private
   */
  extractCVEIds(vulnerabilities) {
    const cveSet = new Set();
    
    vulnerabilities.forEach(vuln => {
      const cveId = this.extractCVEId(vuln.description);
      if (cveId) {
        cveSet.add(cveId);
      }
    });
    
    return Array.from(cveSet);
  }

  /**
   * Extracts a CVE ID from a string if present
   * @private
   */
  extractCVEId(text) {
    const cveRegex = /CVE-\d{4}-\d{4,}/i;
    const match = text.match(cveRegex);
    return match ? match[0].toUpperCase() : null;
  }

  /**
   * Gets a risk assessment based on severity and EPSS score
   * @param {number} severity - Severity level (1-5)
   * @param {number} [epssScore] - Optional EPSS score (0-1)
   * @returns {string} Risk assessment
   */
  getRiskAssessment(severity, epssScore) {
    if (epssScore === undefined) {
      return this.getSeverityAssessment(severity);
    }

    // Combine severity and EPSS score for risk assessment
    const riskScore = (severity / 5) * 0.5 + (epssScore * 0.5);
    
    if (riskScore > 0.7) return 'Critical Risk';
    if (riskScore > 0.5) return 'High Risk';
    if (riskScore > 0.3) return 'Medium Risk';
    return 'Low Risk';
  }

  /**
   * Gets severity assessment based on severity level
   * @private
   */
  getSeverityAssessment(severity) {
    if (severity >= 4.5) return 'Critical Severity';
    if (severity >= 3.5) return 'High Severity';
    if (severity >= 2.5) return 'Medium Severity';
    return 'Low Severity';
  }
}

// Create and export a singleton instance
module.exports = new VulnerabilityManager();
